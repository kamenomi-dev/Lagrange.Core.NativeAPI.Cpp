#pragma once

#include "wrapper.h"
#include "native_model.h"

#include <typeindex>
#include <type_traits>

#define MODEL_MESSAGE NativeModel::Message::

namespace LagrangeCore {
namespace WrappedModel::Message {

struct IEntity {
    std::type_index type() const { return typeid(IEntity); };
};

struct Image : public IEntity {
    std::string FileUrl;
    std::string FileName;
    std::string FileSha1;
    UINT        FileSize = 0;
    std::string FileMd5;
    FLOAT       ImageWidth  = 0.f;
    FLOAT       ImageHeight = 0.f;
    INT         SubType     = NULL;
    std::string Summary;
    UINT        RecordLength = NULL;

    std::type_index type() const { return typeid(Image); }

    Image(
        MODEL_MESSAGE Entity::ImageEntity* entity
    ) {
        FileUrl      = entity->FileUrl;
        FileName     = entity->FileName;
        FileSha1     = entity->FileSha1;
        FileSize     = entity->FileSize;
        FileMd5      = entity->FileMd5;
        ImageWidth   = entity->ImageWidth;
        ImageHeight  = entity->ImageHeight;
        SubType      = entity->SubType;
        Summary      = entity->Summary;
        RecordLength = entity->RecordLength;
    }

    // 这里没必要，因为 wrapped_model 是供使用者的，没必要做转换。
    // operator NativeModel::Message::Entity::ImageEntity() const {
    //    NativeModel::Message::Entity::ImageEntity entity{};
    //    entity.FileUrl      = FileUrl;
    //    entity.FileName     = FileName;
    //    entity.FileSha1     = FileSha1;
    //    entity.FileSize     = FileSize;
    //    entity.FileMd5      = FileMd5;
    //    entity.ImageWidth   = ImageWidth;
    //    entity.ImageHeight  = ImageHeight;
    //    entity.SubType      = SubType;
    //    entity.Summary      = Summary;
    //    entity.RecordLength = RecordLength;
    //    return entity;
    //}
};

class EntitySequence {
  private:
    std::vector<IEntity> _entities;

  public:
    EntitySequence();

    static EntitySequence FromNative(
        NativeModel::Message::BotMessage& message
    ) {
        EntitySequence sequence;
        sequence._entities.reserve(message.EntityLength);
        for (int i = 0; i < message.EntityLength; i++) {
            auto entity = (MODEL_MESSAGE TypedEntity*)(message.Entities + i * sizeof(MODEL_MESSAGE TypedEntity));

            switch (entity->Type) {
            case MODEL_MESSAGE Entity::EntityType::ImageEntity:
                sequence._entities.emplace_back(Image((MODEL_MESSAGE Entity::ImageEntity*)entity->Entity));
                break;
            
            default:
                spdlog::warn(
                    "[EntitySequence] Unsupported Message Type Index: {}! You may need to update the Library.", entity->Type
                );
                break;
            }
        }
        return sequence;
    }

    // Generated By ChatGPT.
    template <typename... Types>
    bool ExpectSequence() {
        constexpr std::size_t N = sizeof...(Types);
        if (_entities.size() < N) {
            return false;
        }

        std::type_index expected[] = {typeid(Types)...};
        for (std::size_t i = 0; i < N; ++i) {
            if (_entities[i].type != expected[i]) {
                return false;
            }
        }

        return true;
    }
};
} // namespace WrappedModel::Message

namespace WrappedModel {
// Todo: Implement Group, User & Friend classes.
class Group {
  public:
    Group(uint64_t group_id);
};

class User {
  public:
    User(uint64_t user_id);
};

class Friend : public User {
  public:
    Friend(uint64_t user_id) : User(user_id) {};
};

using Stranger = User;
} // namespace WrappedModel
} // namespace LagrangeCore

#undef MODEL_MESSAGE